using Content.Client.UserInterface.Systems.Alerts.Controls;
using Content.Client.UserInterface.Systems.NativeActions.Widgets;
using Content.Shared.Alert;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Prototypes;

namespace Content.Client.UserInterface.Systems.Alerts.Widgets;

/// <summary>
///     The status effects display on the right side of the screen.
/// </summary>
[GenerateTypedNameReferences]
public sealed partial class AlertsUI : UIWidget
{
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

    // also known as Control.Children?
    private readonly Dictionary<AlertKey, AlertControl> _alertControls = new();

    private NativeActionsUIController _NAController;

    // Well, spagetti code.
    private NativeActionsGui? _nativeActionsGui
    {
        get => _NAController.NativeActions;
    }

    private BoxContainer? _mainAlertsContainer
    {
        get => _NAController.MainAlertsContainer;
    }

    public AlertsUI()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _NAController = UserInterfaceManager.GetUIController<NativeActionsUIController>();
    }

    public void SyncControls(AlertsSystem alertsSystem,
        AlertOrderPrototype? alertOrderPrototype,
        IReadOnlyDictionary<AlertKey,
        AlertState> alertStates)
    {
        // remove any controls with keys no longer present
        if (SyncRemoveControls(alertStates))
            return;

        // now we know that alertControls contains alerts that should still exist but
        // may need to updated,
        // also there may be some new alerts we need to show.
        // further, we need to ensure they are ordered w.r.t their configured order
        SyncUpdateControls(alertsSystem, alertOrderPrototype, alertStates);
    }

    public void ClearAllControls()
    {
        foreach (var alertControl in _alertControls.Values)
        {
            alertControl.OnPressed -= AlertControlPressed;
            alertControl.Dispose();
        }

        _alertControls.Clear();
    }

    public event EventHandler<ProtoId<AlertPrototype>>? AlertPressed;

    private bool SyncRemoveControls(IReadOnlyDictionary<AlertKey, AlertState> alertStates)
    {
        var toRemove = new List<AlertKey>();
        foreach (var existingKey in _alertControls.Keys)
        {
            if (!alertStates.ContainsKey(existingKey))
                toRemove.Add(existingKey);
        }

        foreach (var alertKeyToRemove in toRemove)
        {
            _alertControls.Remove(alertKeyToRemove, out var control);
            if (control == null)
                return true;

            // If we wanna move some Alerts into another UI.
            var alertControlsContainer = EnsureControlsContainer(alertKeyToRemove);
            alertControlsContainer.Children.Remove(control);
        }

        return false;
    }

    private BoxContainer EnsureControlsContainer(AlertKey alertKey)
    {
        var alertControlsContainer = AlertContainer;

        // If we wanna move some Alerts into another UI.
        // TODO: Move some definition into prototypes
        if (_prototypeManager.TryIndex<AlertCategoryPrototype>(alertKey.AlertCategory, out var alertCategory))
        {
            if (_nativeActionsGui == null)
                return alertControlsContainer;

            switch (alertCategory.Group)
            {
                case "NativeActions":
                    alertControlsContainer = _nativeActionsGui.ActionsContainer;
                    break;
                case "Intents":
                    alertControlsContainer = _nativeActionsGui.IntentsContainer;
                    if (alertControlsContainer.ChildCount >= 2)
                        alertControlsContainer = _nativeActionsGui.IntentsContainer2;
                    break;
                case "MainInfo":
                    if (_mainAlertsContainer != null)
                        alertControlsContainer = _mainAlertsContainer;
                    break;
            }
        }

        return alertControlsContainer;
    }

    private void SyncUpdateControls(AlertsSystem alertsSystem, AlertOrderPrototype? alertOrderPrototype,
        IReadOnlyDictionary<AlertKey, AlertState> alertStates)
    {
        foreach (var (alertKey, alertState) in alertStates)
        {
            if (!alertKey.AlertType.HasValue)
            {
                Logger.WarningS("alert", "found alertkey without alerttype," +
                                         " alert keys should never be stored without an alerttype set: {0}", alertKey);
                continue;
            }

            var alertType = alertKey.AlertType.Value;
            if (!alertsSystem.TryGet(alertType, out var newAlert))
            {
                Logger.ErrorS("alert", "Unrecognized alertType {0}", alertType);
                continue;
            }

            if (_alertControls.TryGetValue(newAlert.AlertKey, out var existingAlertControl) &&
                existingAlertControl.Alert.ID == newAlert.ID)
            {
                // key is the same, simply update the existing control severity / cooldown
                existingAlertControl.SetSeverity(alertState.Severity);
                if (alertState.ShowCooldown)
                    existingAlertControl.Cooldown = alertState.Cooldown;
            }
            else
            {
                // If we wanna move some Alerts into another UI.
                var alertControlsContainer = EnsureControlsContainer(alertKey);

                if (existingAlertControl != null)
                    alertControlsContainer.Children.Remove(existingAlertControl);

                // this is a new alert + alert key or just a different alert with the same
                // key, create the control and add it in the appropriate order
                var newAlertControl = CreateAlertControl(newAlert, alertState);

                //TODO: Can the presenter sort the states before giving it to us?
                if (alertOrderPrototype != null)
                {
                    var added = false;
                    foreach (var alertControl in alertControlsContainer.Children)
                    {
                        if (alertOrderPrototype.Compare(newAlert, ((AlertControl) alertControl).Alert) >= 0)
                            continue;

                        var idx = alertControl.GetPositionInParent();
                        alertControlsContainer.Children.Add(newAlertControl);
                        newAlertControl.SetPositionInParent(idx);
                        added = true;
                        break;
                    }

                    if (!added)
                        alertControlsContainer.Children.Add(newAlertControl);
                }
                else
                {
                    alertControlsContainer.Children.Add(newAlertControl);
                }

                _alertControls[newAlert.AlertKey] = newAlertControl;
            }
        }
    }

    private AlertControl CreateAlertControl(AlertPrototype alert, AlertState alertState)
    {
        (TimeSpan, TimeSpan)? cooldown = null;
        if (alertState.ShowCooldown)
            cooldown = alertState.Cooldown;

        // TODO: Also need refactor alerts for making any custom buttons, like intents
        if (_prototypeManager.TryIndex<AlertCategoryPrototype>(alert.Category, out var alertCategory) && alertCategory.Group == "Intents")
        {
            var alertControl = new AlertControl(alert, alertState.Severity, 2, 16)
            {
                Cooldown = cooldown
            };

            // Set names for keyboard binds
            switch (alert.ID)
            {
                case "IntentHelp":
                    alertControl.Name = "0";
                    break;
                case "IntentDisarm":
                    alertControl.Name = "1";
                    break;
                case "IntentGrab":
                    alertControl.Name = "2";
                    break;
                case "IntentHarm":
                    alertControl.Name = "3";
                    break;
            }

            alertControl.OnPressed += AlertControlPressed;
            return alertControl;
        }
        else
        {
            var alertControl = new AlertControl(alert, alertState.Severity)
            {
                Cooldown = cooldown
            };
            alertControl.OnPressed += AlertControlPressed;
            return alertControl;
        }
    }

    private void AlertControlPressed(BaseButton.ButtonEventArgs args)
    {
        if (args.Button is not AlertControl control)
            return;

        if (args.Event.Function != EngineKeyFunctions.UIClick)
            return;

        AlertPressed?.Invoke(this, control.Alert.ID);
    }
}
